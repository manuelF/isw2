\documentclass{article}
\usepackage{color}
\usepackage{geometry}
\usepackage{pdflscape}
\usepackage{multirow}
\usepackage[inline]{enumitem}
\newgeometry{margin=2cm}

\usepackage{listings}
\lstset{ %
	language=C++,                % choose the language of the code
	basicstyle=\footnotesize\ttfamily,       % the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
	stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
	numbersep=5pt,                  % how far the line-numbers are from the code
	backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	frame=single,           % adds a frame around the code
	tabsize=4,          % sets default tabsize to 2 spaces
	captionpos=b,           % sets the caption-position to bottom
	breaklines=true,        % sets automatic line breaking
	breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
}



\newcommand{\prodback}{\textit{Product Backlog}}
\newcommand{\sprintback}{\textit{Sprint Backlog}}

\newcommand{\condiciones}{\texttt{Lector Condiciones Externas}}
\newcommand{\sensarCondiciones}{\texttt{sensarCondicionesExternas}}
\newcommand{\decisiones}{\texttt{Tomador Decisiones}}
\newcommand{\tomarDecisiones}{\texttt{tomarDecisiones}}
\newcommand{\timer}{\texttt{Timer}}
\newcommand{\arduino}{\texttt{Arduino}}
\newcommand{\cliente}{\texttt{Cliente}}
\newcommand{\servidor}{\texttt{Servidor}}

\newcommand{\empezarenum}{\begin{enumerate*}[label=(\arabic*.),itemjoin={\newline}]}
\newcommand{\terminarenum}{\end{enumerate*}}


\def \aag {\textbf{As a Gardener I Want to }}
\def \aab {\textbf{As a Botanist I Want to }}
\def \sic {\textbf{So I Can }}

%para las tablas
\def \ancho {p{5cm}}

\begin{document}

  \title{Trabajo Pr\'actico de Programaci\'on FALTA}
  \date{Segundo cuatrimestre, $2014$}
  \author{Grupo: FALTA \\ Gallardo Guillermo, LU:$032/10$\\ Luis Scoccola, LU:$382/10$}

  \maketitle
 
  \newpage

%  \section{\prodback}
  \input{productbacklog.tex}

%  \section{\sprintback}
  \input{sprintbacklog.tex}

  \section{Seguimiento}
    \subsection{Burndown Charts}

  \section{Dise\~no}

    \subsection{Diagrama de clases}

    \paragraph{Abstracci\'on de los sensores}
    El enunciado habla sobre tres tipos de sensores bien concretos.
    Decidimos modelar a cada uno de ellos por serparado. Es decir, no realizamos
    una abstracci\'on para Sensor. El motivo para sustentar esta decisi\'on
    que se refleja tanto a nivel de dise\~no como a nivel implementativo es
    el siguiente.

    Si bien los sensores se comportan de forma semejante,
    o mejor dicho, son polimorficos con respecto al mensaje \texttt{Sensar},
    no lo son vistos desde la perspectiva de un lenguaje est\'aticamente tipado.
    Esto es porque cada sensor devuelve un valor de un tipo o clase distinta.
    Una soluci\'on a esto hubiese sido no modelar los tipos de los valores de
    retorno con distintas clases, y poner \'unicamente un valor num\'erico
    (al estilo \textit{double}). Nos
    pareci\'o que perd\'iamos mucha sem\'antica con esta soluci\'on.

    Otra soluci\'on podr\'ia haber sido utilizar el patr\'on \textit{visitor}.
    Pero nos pareci\'o que complejiza el modelo y la implementaci\'on innecesariamente.

    Al no haber realizado esta abstracci\'on se podr\'ia objetar que restringimos
    la extensibilidad en cuanto a m\'as o distinto tipo de sensores.
    Para responder a esta posible objeci\'on debe observarse el modelado del
    \condiciones, el de los sensores y el del
    \arduino. Al desligar el sensor del \arduino conseguimos
    sensores vers\'atiles, en el sentido de que pueden depender de varios sensores
    reales (es decir del mundo real). M\'as a\'un, los sensores modelados
    permiten tener l\'ogica interna para manejar los sensores del mundo real
    correctamente.
    (FALTA nombrar patron composit)

    Si se quisieran agregar nuevos tipos de sensores deber\'ian agregarse nuevas
    clases de sensores al modelo. Por supuesto deber\'a tambi\'en modificarse
    el c\'odigo de \condiciones para que se comunique
    con los nuevos sensores. Pero consideramos que esto es b\'asicamente inevitable,
    por m\'as que se realice una abstracci\'on del sensor, pues la l\'ogica
    de todo el sistema depender\'a, en este caso, de nuevos par\'ametros.

    \paragraph{Abstracci\'on de los actuadores}
    Para el caso de los actuadores nos encontramos con una situaci\'on semejante
    a la reci\'en presentada. En este caso, sin embargo, optamos por realizar
    una abstracci\'on. Esta se denomina \texttt{Actuador Simple}. El nombre
    refleja la naturaleza sencilla de los actuadores modelados: b\'asicamente
    responden al mensaje \texttt{Suministrar} con una cantidad. Donde
    \texttt{Cantidad} es una clase que representa valores discretos y que adem\'as
    son interpretados por cada actuador de forma independiente.

    Esta abstracci\'on permite realizar una calibraci\'on de cada actuador a la
    hora de inicializar el sistema, que queda
    guardada en el actuador. Por otro lado permite, al \decisiones,
    devolver decisiones en un formato semejante al almacenado en el
    \texttt{Plan Maestro} (y el descripto en el enunciado), que \'unicamente
    especifica cantidades aproximadas, las modeladas en la clase
    \texttt{Cantidades}.

    \paragraph{Interacci\'on entre \decisiones y \condiciones}
    Inicialmente decidimos tener un \timer que peri\'odicamente llame a \condiciones
    con el mensaje \sensarCondiciones. Una vez recopilada la informaci\'on de los
    sensores, \condiciones mandaba el mensaje \tomarDecisiones a \decisiones.

    El problema con este protocolo es que \decisiones depende de \condiciones
    para entrar en juego. Por otro lado, \condiciones termina dependiendo de
    \condiciones a nivel dise\~no e implementaci\'on, lo cual no resulta razonable,
    pues son partes independientes del sistema y este acoplamiento puede ser evitado.

    Para esto ustamo dos \timer. Los objetos que antes estaban acoplados, ahora
    pueden actuar libremente, siendo activados por \timer. \condiciones, luego
    de sensar, escribe los resultados en el historial. \decisiones lee estos
    resultados al ser activado, y toma una decisi\'on.

    Otro aspecto interesante que surgi\'o al analizar esta interacci\'on es
    el comportamiento estilo \textit{observer} que se da entre \timer y
    \condiciones y entre \timer y \decisiones. Intentamos utilizar el patr\'on
    cl\'asico en el dise\~no, pero no result\'o natural. Los motivos son
    principalmente dos:
    \begin{itemize}
        \item El \timer se comporta como un observable, pero tiene una sutileza:
            debe ajustarse el tiempo. Si bien esto puede ser solucionado de
            forma prolija agregando objetos, decidimos que complicaba el dise\~no
            por una cuesti\'on \'unicamente formal, que no facilitaba nada
            concreto.
        \item Siempre que se siga usando al \timer como tal, el dise\~no seguir\'a
            siendo extensible, en este aspecto. Pues la funcionalidad de \timer
            no deber\'ia cambiar, por la esencia misma de un \timer.
    \end{itemize}
    Por estos motivos, creemeos que la extensibilidad no fue restringida al
    no utilizar un \textit{observer} cl\'asico.




    \paragraph{\cliente y \servidor}
    Para que el sistema pueda funcionar real\'isticamente, nos result\'o esencial
    desacoplar totalmente el funcionamiento autom\'atico del mismo: manejo de
    actuadores, recopilar informaci\'on, tomar decisiones, etc. Del funcionamiento
    asincr\'onico debido al uso por parte del usuario: guardar entradas sobre la
    planta en el historial, realizar consultas, etc.

    Para esto separamos el programa en dos procesos. El cliente y el servidor.
    Que a su vez, dieron lugar a dos objetos: \cliente y \servidor.

    \paragraph{Bootstrapping}

    \paragraph{Mensaje}

    \paragraph{Historial}

    \subsection{Diagramas de objetos}

    \subsection{Diagramas de FALTA}

  \section{Retrospectiva}
    \subsection{Inconvenientes encontrados}
    \paragraph{Tareas programadas en el \sprintback}
    Al momento de definir las tareas no ten\'iamos experiencia en separar y definir
    tareas concretas para un proyecto. A pesar de nuestro intento por modularizar
    las tareas y no olvidar partes esenciales result\'o que b\'asicamente obviamos
    las tareas de modelado y dise\~no. Por otro lado, las tareas de implementaci\'on
    resultaron modularizadas de forma poco conveniente, pues no se correspond\'ian
    con las clases, que fueron dise\~nadas luego. Si bi\'en el \sprintback tuvo
    este inconveniente, a la hora de ponernos a trabajar notamos r\'apidamente
    el problema, y logramos distribuirnos las tareas de forma eficiente.

    \subsection{Proxima iteraci\'on}

    \paragraph{Historial visitor}

\end{document}
